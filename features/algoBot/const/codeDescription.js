export const codeDescription = {
    stack: "💡스택\n" + "📚 스택은 선입후출의 자료구조에요.\n" + "👉 DFS와 같은 알고리즘 문제풀이를 진행할 때 활용해요.\n\n",
    queue: "💡큐\n" + "📚 큐는 선입선출의 자료구조에요.\n" + "👉 BFS와 같은 알고리즘 문제풀이를 진행할 때 활용해요.\n\n",
    heap: "💡힙(우선순위큐)\n\n\n" + "📚 힙은 우선순위가 높은 순서대로 값을 배치한 트리 기반의 자료구조에요.\n" + "👉 우선순위를 고려해야하는 문제에서 주로 활용해요.\n\n\n" + "⚠️\n" + "1️⃣ 트리 기반의 자료구조이기에 트리에 대한 이해도가 필요해요.\n" + "2️⃣ 알고리즘 문제풀이 시 input 값이 많은 경우 이와 같은 방법을 활용해야해요.\n" + "3️⃣ 값이 삽입되고 제거될 때 트리 구조를 재배치하는 로직을 구현해야해요.\n\n",
    linkedlist: "💡연결리스트\n\n\n" + "📚 노드의 모음으로 구성된 자료구조로, 각 노드가 다음 노드의 위치정보를 포함한 자료구조입니다. 노드가 꼬리에 꼬리를 무는 구조인 셈이죠. \n" + "👉 탐색 시간복잡도가 높지만, 삽입/삭제에서는 강점을 지니는 자료구조에요.\n\n\n" + "⚠️\n" + "1️⃣ 연결리스트는 각 노드가 다음 노드를 기억하기에 배열처럼 메모리에 연속적인 주소로 저장되어 있을 필요가 없어요.\n" + "2️⃣ 특정 값을 찾기 위해선 하나하나 확인하는 과정을 거쳐야하므로 탐색 부분에선 효율적이지 못해요.\n" + "3️⃣ 값이 삽입되고 삭제될 때, 주변 노드의 값만 수정하면 되므로 재정렬이 동반되는 배열보다 효과적이에요.\n\n",
    binarysearchtree: "💡이중탐색트리(Binary Search Tree, BST)\n\n\n" + "📚 이진트리를 활용한 자료구조 중 하나에요. 왼쪽 서브트리엔 해당 노드보다 작은값을, 우측 서브트리엔 해당 노드보다 큰 값을 배치하는 규칙으로 구성되어 있어요. \n" + "👉 이 구조의 경우 O(log(n)) 의 시간복잡도의 자료구조에요. \n\n\n" + "⚠️\n" + "1️⃣ 이중 트리에 대한 이해도가 필요해요.\n" + "2️⃣ 한쪽으로만 치우친 이중트리를 편향 이진트리라고하고, 이 경우엔 연결리스트와 동일한 형태의 자료구조로 시간복잡도가 O(n)가 될 수 있어요.\n",
    dfs: "💡깊이 우선 탐색(Depth First Search, DFS)\n\n\n" + "📚 DFS는 이름 그대로 끝까지 들어가보는 탐색방식입니다. 일단 끝까지 가보고, 더이상 탐색할 수 없다면 탐색해온 경로를 다시 되돌아가 탐색하지 않았던 길을 탐색합니다. \n" + "👉 모든 경우의 수를 고려해야하는 경우 등에 DFS를 활용해요. \n\n\n" + "⚠️\n" + "1️⃣ 이차원 배열, 재귀활용, 노드와 간선 등 다양한 환경에서 해당 알고리즘을 구현하는 문제가 출제될 수 있어요.\n" + "2️⃣ 재귀로 구현하는 경우 Depth를 주의해야해요. 스택 오버플로우 에러가 발생할 수 있어요.\n",
    bfs: "💡너비 우선 탐색(Breadth First Search, DFS)\n\n\n" + "📚 BFS는 주변을 살피며 탐색하는 방식이라고 생각하면 이해하기 쉬워요. 탐색 가능한 노드를 확인하고 탐색 가능하다면 그 방향으로 쭉쭉 들어가며 탐색했던 DFS와 달리 BFS는 주변에 갈 수 있는 모든 노드들을 확인하면서 탐색을 진행해요. \n" + "👉 최단 경로 계산, 퍼져나가는 문제(전염병 등) 관련된 문제를 풀 때 자주 활용해요. \n\n\n" + "⚠️\n" + "1️⃣ 이차원 배열, 재귀활용, 노드와 간선 등 다양한 환경에서 해당 알고리즘을 구현하는 문제가 출제될 수 있어요.\n",
}